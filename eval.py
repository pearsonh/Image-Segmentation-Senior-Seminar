''' Functions to run image segmentation evaluation metrics.
    Metrics include:
        BDE (an edge-based metric)
        bipartite region matching evaluated with Jaccard measure'''

import numpy as np
import networkx as nx
import scipy.ndimage as sp
import scipy.optimize as opt
from thresholding import baseline_thresholding
from parser import import_berkeley, import_weizmann
from PIL import Image
import time
import sys

def processSegmentationWithKernels(segmentation):
    '''Create a list of pixels that are on the edge of a segment for a given
        segmentation. The input segmentation is a 2D numpy array where each
        element is the label of the segment that pixel falls in, and the output
        is a nested np array of coordinates describing the (x, y) locations of edge pixels.
        Does edge pixel checks by processing the segmentation with kernel convolution.
        Each kernel checks whether one of the four neighboring pixels is in the same
        segment as the middle pixel--if the middle pixel is the same, then in the
        convolved array it will now be 0. By taking the absolute value of each of the
        convolved arrays and taking their sum, any pixel that is non-zero will be an
        edge pixel.

        A pixel is considered 'on an edge' if at least one pixel
        on the four sides of it lies in a different segment (or if it is on the
        actual edge of the image).

        For example, suppose segmentation is the following:
        0 0 0 1 1 1
        0 0 0 1 1 1
        0 0 0 1 1 1
        0 0 0 1 1 1

        Then edge pixels are marked by X's below:
        X X X X X X
        X 0 X X 1 X
        X 0 X X 1 X
        X X X X X X

        Returns a list of all the non-zero elements in this sum array (i.e. all the
        edge pixel coordinates).'''
    kernelTop = np.asarray([[0,-1,0],[0,1,0],[0,0,0]])
    kernelBottom = np.asarray([[0,0,0],[0,1,0],[0,-1,0]])
    kernelLeft = np.asarray([[0,0,0],[-1,1,0],[0,0,0]])
    kernelRight = np.asarray([[0,0,0],[0,1,-1],[0,0,0]])
    convolvedTop = abs(sp.convolve(segmentation, kernelTop))
    convolvedBottom = abs(sp.convolve(segmentation, kernelBottom))
    convolvedLeft = abs(sp.convolve(segmentation, kernelLeft))
    convolvedRight = abs(sp.convolve(segmentation, kernelRight))
    sumArr = convolvedTop + convolvedBottom + convolvedLeft + convolvedRight
    nz = np.nonzero(sumArr)

    #add the coordinates of outer edge pixels of the image
    height,length = segmentation.shape
    top_range = np.expand_dims(np.arange(length),axis=0)
    top_zeros = np.expand_dims(np.zeros(length),axis=0)
    top_edges = np.concatenate((top_zeros,top_range), axis=0)

    bottom_range = np.expand_dims(np.arange(length),axis=0)
    bottom_fill = np.expand_dims(np.full(length, height - 1),axis=0)
    bottom_edges = np.concatenate((bottom_fill,bottom_range), axis=0)

    left_range = np.expand_dims(np.arange(1,height - 1),axis=0)
    left_zeros = np.expand_dims(np.zeros(height - 2),axis=0)
    left_edges = np.concatenate((left_range,left_zeros), axis=0)

    right_range = np.expand_dims(np.arange(1,height -1),axis=0)
    right_fill = np.expand_dims(np.full(height - 2, length - 1),axis=0)
    right_edges = np.concatenate((right_range,right_fill), axis=0)

    nz = np.concatenate((top_edges, bottom_edges, nz, left_edges, right_edges), axis=1)

    # make sure there are no duplicate edges in the list
    coords = np.unique(np.transpose(nz), axis=0)
    return coords

def bde(segmentation,groundtruth):
    ''' Given a segmentation generated by one of our algorithms and a ground truth
        segmentation (both 2D numpy arrays of segment labels corresponding to each pixel),
        return the BDE measure for this pair of segmentations (a positive float).

        The BDE metric is calculated as the average of [the sum, over all the edge pixels
        in segmentation, of the distances from the nearest edge pixel in the ground
        truth] and [the sum, over all the edge pixels in ground truth, of the distances
        from the nearest edge pixel in segmentation]. More broadly, it is a measure
        of how closely the edges in segmentation match the edges in groundtruth.
        A small BDE measure means a closer fit for edges.'''
    height,length = segmentation.shape
    # locate edge pixels in each segmentation and store these as lists of coordinates
    segEdges = processSegmentationWithKernels(segmentation)
    truEdges = processSegmentationWithKernels(groundtruth)
    numSegEdges, _ = segEdges.shape
    numTruEdges, _ = truEdges.shape
    # create matrices of tuples whose rows/cols are copies of segEdges and truEdges
    # (we get A and B with dimensions numSegEdges by numTruEdges, with the tuples
    # corresponding to true edges on the rows of A and the tuples corresponding
    # to seg edges on the columns of B)
    A = np.tile(truEdges, (numSegEdges, 1))
    B = np.tile(segEdges, (numTruEdges, 1))
    A = np.reshape(A, (numSegEdges, numTruEdges, 2))
    B = np.transpose(np.reshape(B, (numTruEdges, numSegEdges, 2)), (1,0,2))
    # C is a matrix of euclidean distances between every pair of true and segEdges
    C = np.sqrt(np.sum(np.square(A - B), axis=2))
    # find the min value for each row and each column of C.
    # this is equivalent to finding the min distance from each true edge to a seg
    # edge, and the min distance from each seg edge to a true edge
    minsTruToSeg = np.sum(np.amin(C, axis=0))
    minsSegToTru = np.sum(np.amin(C, axis=1))
    return (minsTruToSeg / len(truEdges) + minsSegToTru / len(segEdges)) / 2

def region_based_eval(truth, generated):
    ''' Calculates a Jaccard score for the similarity of the generated segmentation to the
        ground truth segmentation, based on a bipartite matching of segments, or regions.
        Given the ground truth and generated segmentation as 2D numpy arrays of
        segment labels for each pixel, decide which segments best correspond in ground
        truth and generated segmentation, then return the Jaccard measure (between 0 and 1)
        for how closely these segments match up.

        The Jaccard metric is calculated as the average, over all ground truth/generated
        segmentation region pairs, of the intersection of the corresponding regions
        divided by the union of these regions. A larger Jaccard measure means
        a closer overlap in regions.'''
    height,length = truth.shape

    max_true=np.amax(truth)+1
    max_alg=np.amax(generated)+1 #axis??
    weights =  np.array([[height*length]*max_alg]*max_true)
    true_sizes=np.zeros(max_true)
    alg_sizes=np.zeros(max_alg)
    for i in range(height):
        for j in range(length):
            weights[truth[i,j], generated[i,j]]-=1
            true_sizes[truth[i,j]]+=1
            alg_sizes[generated[i,j]]+=1

    true_ind, alg_ind=opt.linear_sum_assignment(weights)
    total=0
    for i in range(1, len(alg_ind)):
        match = weights[true_ind[i], alg_ind[i]]
        intersect = height*length-match
        print(intersect)
        jaccard = intersect/(alg_sizes[alg_ind[i]]+true_sizes[true_ind[i]]-intersect)
        total+=jaccard
    return total/(len(alg_sizes)-1)

if __name__ == "__main__":
    ''' Test evaluation functions on simple segmentations'''
    # Test BDE
    # testarray1 = np.asarray([[1,1,1,1,1,0,0,0],
    #               [1,1,1,1,1,0,0,0],
    #               [1,1,1,0,0,0,0,0],
    #               [1,1,0,0,0,0,0,0]])
    #
    # testarray2 = np.asarray([[0,0,0,1,1,1,1,1],
    #               [0,0,0,0,1,1,1,1],
    #               [0,0,0,0,0,1,1,1],
    #               [0,0,0,0,0,0,1,1]])
    #
    # print(bde(testarray1, testarray2))
    #print(region_based_eval(testarray1, testarray2))

    # Test bipartite matching
    # true = np.asarray([[1,1,1,2,2],
    #         [1,2,2,2,3],
    #         [1,2,4,4,3],
    #         [5,5,4,3,3],
    #         [5,5,5,5,3]])
    # generation = np.asarray([[2,2,1,1,1],
    #               [2,2,1,3,3],
    #               [2,1,4,3,3],
    #               [5,5,4,3,3],
    #               [5,5,5,3,3]])
    #
    # print(bde(true, generation))
    # print(region_based_eval(true, generation))

    # test on a real image
    filename = "b2chopper008.png"
    img = Image.open(filename)
    print(filename)
    generated = baseline_thresholding(img).astype('uint8')
    image = Image.fromarray(generated*255, mode="L")
    image.show()
    truth = import_weizmann("b2chopper008_4.png")
    start=time.time()
    bde = bde(truth, generated)
    stop=time.time()
    print("time for bde is ", stop - start)
    print("bde val is ", bde)
