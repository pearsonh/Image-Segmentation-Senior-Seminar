''' Functions to run image segmentation evaluation metrics.
    Metrics include:
        BDE (an edge-based metric)
        bipartite region matching evaluated with Jaccard measure'''

import numpy as np
import networkx as nx
import scipy.ndimage as sp
from thresholding import baseline_thresholding
from parser import import_berkeley
from PIL import Image
import time
import sys

def euclideanDistance(x1,y1,x2,y2):
    ''' Return the Euclidean distance between points (x1, y1) and (x2, y2)'''
    return ((x1-x2)**2+(y1-y2)**2)**(.5)

def createListOfEdgePixels(segmentation):
    ''' Create a list of pixels that are on the edge of a segment for a given
        segmentation. The input segmentation is a 2D numpy array where each
        element is the label of the segment that pixel falls in, and the output
        is an array of tuples describing the (x, y) locations of edge pixels.
        A pixel is considered 'on an edge' if at least one pixel
        on the four sides of it lies in a different segment.

        For example, suppose segmentation is the following:
        0 0 0 1 1 1
        0 0 0 1 1 1
        0 0 0 1 1 1
        0 0 0 1 1 1

        Then edge pixels are marked by X's below:
        0 0 X X 1 1
        0 0 X X 1 1
        0 0 X X 1 1
        0 0 X X 1 1

        Since outer edges of the image will always correspond to segment edges, we do
        not count these as edge pixels (unless a region is one pixel wide along an edge,
        in which case these edge pixels correspond to the inner edge of that segment),
        as they would always be matched to themselves when calculating BDE, giving a
        distance of 0 (thus not contributing anything to the metric).'''
    out = []
    height,length = segmentation.shape
    for i in range(length):
        for j in range(height):
            for x,y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:
                if (x>=0 and y>=0 and x<length and y<height):
                    if (segmentation[y,x] != segmentation[j,i]):
                        out.append((i,j))
                        break
    return out

def processSegmentationWithKernels(segmentation):
    '''Do edge pixel checks by processing the segmentation with kernel convolution.
    Each kernel checks whether one of the four neighboring pixels is in the same
    segment as the middle pixel--if the middle pixel is the same, then in the
    convolved array it will now be 0. By taking the absolute value of each of the
    convolved arrays and taking their sum, any pixel that is non-zero will be an
    edge pixel.

    Returns a list of all the non-zero elements in this sum array (i.e. all the
    edge pixel coordinates).'''
    kernelTop = np.asarray([[0,-1,0],[0,1,0],[0,0,0]])
    kernelBottom = np.asarray([[0,0,0],[0,1,0],[0,-1,0]])
    kernelLeft = np.asarray([[0,0,0],[-1,1,0],[0,0,0]])
    kernelRight = np.asarray([[0,0,0],[0,1,-1],[0,0,0]])
    convolvedTop = abs(sp.convolve(segmentation, kernelTop))
    convolvedBottom = abs(sp.convolve(segmentation, kernelBottom))
    convolvedLeft = abs(sp.convolve(segmentation, kernelLeft))
    convolvedRight = abs(sp.convolve(segmentation, kernelRight))
    sumArr = convolvedTop + convolvedBottom + convolvedLeft + convolvedRight
    coords = np.transpose(np.nonzero(sumArr))
    return coords



def findNearestEdgePixel(pixel, edges):
    ''' Given a pixel, determine which edge pixel in the segmentation is closest
        to pixel in terms of Euclidean distance. Inputs are pixel, an (x, y)
        tuple describing the pixel's location, and edges, a list of tuples describing
        the locations of all pixels on segment edges. Returns the distance
        of the closest edge pixel from pixel (an integer).'''
    bestDistance = float("inf")
    for edge in edges:
        distance = euclideanDistance(pixel[0],pixel[1],edge[0],edge[1])
        if distance < bestDistance:
            bestDistance = distance
    return bestDistance

def bde(segmentation,groundtruth):
    ''' Given a segmentation generated by one of our algorithms and a ground truth
        segmentation (both 2D numpy arrays of segment labels corresponding to each pixel),
        return the BDE measure for this pair of segmentations (a positive float).

        The BDE metric is calculated as the average of [the sum, over all the edge pixels
        in segmentation, of the distances from the nearest edge pixel in the ground
        truth] and [the sum, over all the edge pixels in ground truth, of the distances
        from the nearest edge pixel in segmentation]. More broadly, it is a measure
        of how closely the edges in segmentation match the edges in groundtruth.
        A small BDE measure means a closer fit for edges.'''
    height,length = segmentation.shape
    segEdges = createListOfEdgePixels(segmentation)
    truEdges = createListOfEdgePixels(groundtruth)
    totalDistance = 0
    for edge in segEdges:
        distance = findNearestEdgePixel(edge, truEdges)
        totalDistance += distance
    for edge in truEdges:
        distance = findNearestEdgePixel(edge, segEdges)
        totalDistance += distance
    return totalDistance / (length*height*2)

def bde2(segmentation,groundtruth):
    ''' Given a segmentation generated by one of our algorithms and a ground truth
        segmentation (both 2D numpy arrays of segment labels corresponding to each pixel),
        return the BDE measure for this pair of segmentations (a positive float).

        The BDE metric is calculated as the average of [the sum, over all the edge pixels
        in segmentation, of the distances from the nearest edge pixel in the ground
        truth] and [the sum, over all the edge pixels in ground truth, of the distances
        from the nearest edge pixel in segmentation]. More broadly, it is a measure
        of how closely the edges in segmentation match the edges in groundtruth.
        A small BDE measure means a closer fit for edges.'''
    height,length = segmentation.shape
    # locate edge pixels in each segmentation and store these as lists of coordinates
    segEdges = processSegmentationWithKernels(segmentation)
    truEdges = processSegmentationWithKernels(groundtruth)
    totalDistance = 0
    numSegEdges, _ = segEdges.shape
    numTruEdges, _ = truEdges.shape
    # create matrices of tuples whose rows/cols are copies of segEdges and truEdges
    # (we get A and B with dimensions numSegEdges by numTruEdges, with the tuples
    # corresponding to true edges on the rows of A and the tuples corresponding
    # to seg edges on the columns of B)
    A = np.tile(truEdges, (numSegEdges, 1))
    B = np.tile(segEdges, (numTruEdges, 1))
    A = np.reshape(A, (numSegEdges, numTruEdges, 2))
    B = np.transpose(np.reshape(B, (numTruEdges, numSegEdges, 2)), (1,0,2))
    # C is a matrix of euclidean distances between every pair of true and segEdges
    C = np.sqrt(np.sum(np.square(A - B), axis=2))
    # add the min value for each row and each column of C to the total distance.
    # this is equivalent to finding the min distance from each true edge to a seg
    # edge, and the min distance from each seg edge to a true edge
    totalDistance += np.sum(np.amin(C, axis=0))
    totalDistance += np.sum(np.amin(C, axis=1))
    return totalDistance / (length*height*2)

def region_based_eval(truth, generated):
    ''' Calculates a Jaccard score for the similarity of the generated segmentation to the
        ground truth segmentation, based on a bipartite matching of segments, or regions.
        Given the ground truth and generated segmentation as 2D numpy arrays of
        segment labels for each pixel, decide which segments best correspond in ground
        truth and generated segmentation, then return the Jaccard measure (between 0 and 1)
        for how closely these segments match up.

        The Jaccard metric is calculated as the average, over all ground truth/generated
        segmentation region pairs, of the intersection of the corresponding regions
        divided by the union of these regions. A larger Jaccard measure means
        a closer overlap in regions.'''
    height,length = truth.shape
    G = nx.Graph()
    true_nodes = []
    alg_nodes = []
    for i in range(height):
        for j in range(length):
            true_seg=str(truth[i,j])+"t"
            alg_seg=str(generated[i,j])+"a"
            if G.has_edge(true_seg, alg_seg) == False:
                G.add_edge(true_seg, alg_seg, weight=1)
            else:
                G[true_seg][alg_seg]['weight'] += 1
            if 'size' not in G.nodes[true_seg]:
                G.nodes[true_seg]['size']=1
                G.nodes[true_seg]['bipartite']=0
                true_nodes.append(true_seg)
            else:
                G.nodes[true_seg]['size']+=1
            if 'size' not in G.nodes[alg_seg]:
                G.nodes[alg_seg]['size']=1
                G.nodes[true_seg]['bipartite']=1
                alg_nodes.append(alg_seg)
            else:
                G.nodes[alg_seg]['size']+=1

    for node in true_nodes:
        for node2 in alg_nodes:
            if G.has_edge(node, node2) == False:
                G.add_edge(node, node2, weight=0)

    matching = nx.bipartite.maximum_matching(G)
    total=0
    for node in alg_nodes:
        match = matching[node]
        intersect = G[match][node]['weight']
        jaccard = intersect/(G.nodes[match]['size']+G.nodes[node]['size']-intersect)
        total+=jaccard
    return total/len(alg_nodes)

if __name__ == "__main__":
    ''' Test evaluation functions on simple segmentations'''
    # Test BDE
    testarray1 = np.asarray([[1,1,1,1,1,0,0,0],
                  [1,1,1,1,0,0,0,0],
                  [1,1,1,0,0,0,0,0],
                  [1,1,0,0,0,0,0,0]])

    testarray2 = np.asarray([[0,0,0,1,1,1,1,1],
                  [0,0,0,0,1,1,1,1],
                  [0,0,0,0,0,1,1,1],
                  [0,0,0,0,0,0,1,1]])

    # print(bde(testarray1, testarray2))
    # print(region_based_eval(testarray1, testarray2))

    # Test bipartite matching
    true = np.asarray([[1,1,1,2,2],
            [1,2,2,2,3],
            [1,2,4,4,3],
            [5,5,4,3,3],
            [5,5,5,5,3]])
    generation = np.asarray([[2,2,1,1,1],
                  [2,2,1,3,3],
                  [2,1,4,3,3],
                  [5,5,4,3,3],
                  [5,5,5,3,3]])
    #
    # print(bde(true, generation))
    # print(region_based_eval(true, generation))

    # test on a real image
    filename = "22093.jpg"
    img = Image.open(filename)
    print(filename)
    generated = baseline_thresholding(img)
    truth = import_berkeley("22093.seg")
    start=time.time()
    bde = bde(truth, generated)
    stop=time.time()
    print("time for regular bde is ", stop - start)
    print("bde val is ", bde)

    start=time.time()
    bde2 = bde2(truth, generated)
    stop=time.time()
    print("time for new bde is ", stop - start)
    print("new bde val is ", bde2)
